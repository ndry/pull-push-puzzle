<!DOCTYPE html><html lang="en">
<head><title>pull-push-puzzle</title></head>
<body>
    <script async src="https://unpkg.com/es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">{"imports":{"lodash":"https://unpkg.com/@esm-bundle/lodash@4.17.21/esm/index.js","rxjs":"https://unpkg.com/@esm-bundle/rxjs@7.5.5/esm/es2015/rxjs.min.js","preact":"https://unpkg.com/preact@10.7.2/dist/preact.mjs","preact/hooks":"https://unpkg.com/preact@10.7.2/hooks/dist/hooks.mjs","@emotion/css":"https://unpkg.com/@esm-bundle/emotion@10.0.27/esm/emotion.min.js"}}</script>
    <link rel="modulepreload" href="https://unpkg.com/@esm-bundle/lodash@4.17.21/esm/index.js"/>
<link rel="modulepreload" href="https://unpkg.com/@esm-bundle/rxjs@7.5.5/esm/es2015/rxjs.min.js"/>
<link rel="modulepreload" href="https://unpkg.com/preact@10.7.2/dist/preact.mjs"/>
<link rel="modulepreload" href="https://unpkg.com/preact@10.7.2/hooks/dist/hooks.mjs"/>
<link rel="modulepreload" href="https://unpkg.com/@esm-bundle/emotion@10.0.27/esm/emotion.min.js"/>
    <script type="module">import { options, Fragment, render } from 'preact';
import { cx, css } from '@emotion/css';
import * as rx from 'rxjs';
import * as _ from 'lodash';
import { useState, useEffect } from 'preact/hooks';

var o=0;function e(_,e,n,t,f){var l,s,u={};for(s in e)"ref"==s?l=e[s]:u[s]=e[s];var a={type:_,props:u,key:n,ref:l,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:--o,__source:f,__self:t};if("function"==typeof _&&(l=_.defaultProps))for(s in l)void 0===u[s]&&(u[s]=l[s]);return options.vnode&&options.vnode(a),a}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function pipe(...fns) {
    return (x) => fns.reduce(apply, x);
}
const apply = (x, fn) => fn(x);

const map = (f) => function* (s) { for (const x of s)
    yield f(x); };
const flat = () => function* (s) { for (const x of s)
    yield* x; };
const tap = (f) => function* (s) { for (const x of s) {
    f(x);
    yield x;
} };
const filter = (f) => function* (s) { for (const x of s)
    if (f(x))
        yield x; };
const take = (count) => function* (s) {
    if (--count < 0) {
        return;
    }
    for (const x of s) {
        yield x;
        if (--count < 0) {
            return;
        }
    }
};
const scan = (reducer, seed) => function* (s) { for (const x of s)
    yield seed = reducer(seed, x); };
const toArray = () => (s) => [...s];
function* inf() { for (let i = 0; true; i++) {
    yield i;
} }
const reiterable = (s) => {
    let _s = Array.isArray(s) ? s : undefined;
    if (!_s) {
        _s = [];
        return function* () {
            for (const x of s) {
                yield x;
                _s.push(x);
            }
        };
    }
    return () => _s;
};
const concat = (...sources) => apply(sources, flat());
function* zip3(s1, s2, s3) {
    const _s2 = reiterable(s2);
    const _s3 = reiterable(s3);
    for (const x1 of s1)
        for (const x2 of _s2())
            for (const x3 of _s3())
                yield [x1, x2, x3];
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var immutabilityHelper = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
function stringifiable(obj) {
    // Safely stringify Object.create(null)
    /* istanbul ignore next */
    return typeof obj === 'object' && !('toString' in obj) ?
        Object.prototype.toString.call(obj).slice(8, -1) :
        obj;
}
var isProduction = typeof process === 'object' && process.env.NODE_ENV === 'production';
function invariant(condition, message) {
    if (!condition) {
        /* istanbul ignore next */
        if (isProduction) {
            throw new Error('Invariant failed');
        }
        throw new Error(message());
    }
}
exports.invariant = invariant;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var splice = Array.prototype.splice;
var toString = Object.prototype.toString;
function type(obj) {
    return toString.call(obj).slice(8, -1);
}
var assign = Object.assign || /* istanbul ignore next */ (function (target, source) {
    getAllKeys(source).forEach(function (key) {
        if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
        }
    });
    return target;
});
var getAllKeys = typeof Object.getOwnPropertySymbols === 'function'
    ? function (obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)); }
    /* istanbul ignore next */
    : function (obj) { return Object.keys(obj); };
function copy(object) {
    return Array.isArray(object)
        ? assign(object.constructor(object.length), object)
        : (type(object) === 'Map')
            ? new Map(object)
            : (type(object) === 'Set')
                ? new Set(object)
                : (object && typeof object === 'object')
                    ? assign(Object.create(Object.getPrototypeOf(object)), object)
                    /* istanbul ignore next */
                    : object;
}
var Context = /** @class */ (function () {
    function Context() {
        this.commands = assign({}, defaultCommands);
        this.update = this.update.bind(this);
        // Deprecated: update.extend, update.isEquals and update.newContext
        this.update.extend = this.extend = this.extend.bind(this);
        this.update.isEquals = function (x, y) { return x === y; };
        this.update.newContext = function () { return new Context().update; };
    }
    Object.defineProperty(Context.prototype, "isEquals", {
        get: function () {
            return this.update.isEquals;
        },
        set: function (value) {
            this.update.isEquals = value;
        },
        enumerable: true,
        configurable: true
    });
    Context.prototype.extend = function (directive, fn) {
        this.commands[directive] = fn;
    };
    Context.prototype.update = function (object, $spec) {
        var _this = this;
        var spec = (typeof $spec === 'function') ? { $apply: $spec } : $spec;
        if (!(Array.isArray(object) && Array.isArray(spec))) {
            invariant(!Array.isArray(spec), function () { return "update(): You provided an invalid spec to update(). The spec may " +
                "not contain an array except as the value of $set, $push, $unshift, " +
                "$splice or any custom command allowing an array value."; });
        }
        invariant(typeof spec === 'object' && spec !== null, function () { return "update(): You provided an invalid spec to update(). The spec and " +
            "every included key path must be plain objects containing one of the " +
            ("following commands: " + Object.keys(_this.commands).join(', ') + "."); });
        var nextObject = object;
        getAllKeys(spec).forEach(function (key) {
            if (hasOwnProperty.call(_this.commands, key)) {
                var objectWasNextObject = object === nextObject;
                nextObject = _this.commands[key](spec[key], nextObject, spec, object);
                if (objectWasNextObject && _this.isEquals(nextObject, object)) {
                    nextObject = object;
                }
            }
            else {
                var nextValueForKey = type(object) === 'Map'
                    ? _this.update(object.get(key), spec[key])
                    : _this.update(object[key], spec[key]);
                var nextObjectValue = type(nextObject) === 'Map'
                    ? nextObject.get(key)
                    : nextObject[key];
                if (!_this.isEquals(nextValueForKey, nextObjectValue)
                    || typeof nextValueForKey === 'undefined'
                        && !hasOwnProperty.call(object, key)) {
                    if (nextObject === object) {
                        nextObject = copy(object);
                    }
                    if (type(nextObject) === 'Map') {
                        nextObject.set(key, nextValueForKey);
                    }
                    else {
                        nextObject[key] = nextValueForKey;
                    }
                }
            }
        });
        return nextObject;
    };
    return Context;
}());
exports.Context = Context;
var defaultCommands = {
    $push: function (value, nextObject, spec) {
        invariantPushAndUnshift(nextObject, spec, '$push');
        return value.length ? nextObject.concat(value) : nextObject;
    },
    $unshift: function (value, nextObject, spec) {
        invariantPushAndUnshift(nextObject, spec, '$unshift');
        return value.length ? value.concat(nextObject) : nextObject;
    },
    $splice: function (value, nextObject, spec, originalObject) {
        invariantSplices(nextObject, spec);
        value.forEach(function (args) {
            invariantSplice(args);
            if (nextObject === originalObject && args.length) {
                nextObject = copy(originalObject);
            }
            splice.apply(nextObject, args);
        });
        return nextObject;
    },
    $set: function (value, _nextObject, spec) {
        invariantSet(spec);
        return value;
    },
    $toggle: function (targets, nextObject) {
        invariantSpecArray(targets, '$toggle');
        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;
        targets.forEach(function (target) {
            nextObjectCopy[target] = !nextObject[target];
        });
        return nextObjectCopy;
    },
    $unset: function (value, nextObject, _spec, originalObject) {
        invariantSpecArray(value, '$unset');
        value.forEach(function (key) {
            if (Object.hasOwnProperty.call(nextObject, key)) {
                if (nextObject === originalObject) {
                    nextObject = copy(originalObject);
                }
                delete nextObject[key];
            }
        });
        return nextObject;
    },
    $add: function (values, nextObject, _spec, originalObject) {
        invariantMapOrSet(nextObject, '$add');
        invariantSpecArray(values, '$add');
        if (type(nextObject) === 'Map') {
            values.forEach(function (_a) {
                var key = _a[0], value = _a[1];
                if (nextObject === originalObject && nextObject.get(key) !== value) {
                    nextObject = copy(originalObject);
                }
                nextObject.set(key, value);
            });
        }
        else {
            values.forEach(function (value) {
                if (nextObject === originalObject && !nextObject.has(value)) {
                    nextObject = copy(originalObject);
                }
                nextObject.add(value);
            });
        }
        return nextObject;
    },
    $remove: function (value, nextObject, _spec, originalObject) {
        invariantMapOrSet(nextObject, '$remove');
        invariantSpecArray(value, '$remove');
        value.forEach(function (key) {
            if (nextObject === originalObject && nextObject.has(key)) {
                nextObject = copy(originalObject);
            }
            nextObject.delete(key);
        });
        return nextObject;
    },
    $merge: function (value, nextObject, _spec, originalObject) {
        invariantMerge(nextObject, value);
        getAllKeys(value).forEach(function (key) {
            if (value[key] !== nextObject[key]) {
                if (nextObject === originalObject) {
                    nextObject = copy(originalObject);
                }
                nextObject[key] = value[key];
            }
        });
        return nextObject;
    },
    $apply: function (value, original) {
        invariantApply(value);
        return value(original);
    },
};
var defaultContext = new Context();
exports.isEquals = defaultContext.update.isEquals;
exports.extend = defaultContext.extend;
exports.default = defaultContext.update;
// @ts-ignore
exports.default.default = module.exports = assign(exports.default, exports);
// invariants
function invariantPushAndUnshift(value, spec, command) {
    invariant(Array.isArray(value), function () { return "update(): expected target of " + stringifiable(command) + " to be an array; got " + stringifiable(value) + "."; });
    invariantSpecArray(spec[command], command);
}
function invariantSpecArray(spec, command) {
    invariant(Array.isArray(spec), function () { return "update(): expected spec of " + stringifiable(command) + " to be an array; got " + stringifiable(spec) + ". " +
        "Did you forget to wrap your parameter in an array?"; });
}
function invariantSplices(value, spec) {
    invariant(Array.isArray(value), function () { return "Expected $splice target to be an array; got " + stringifiable(value); });
    invariantSplice(spec.$splice);
}
function invariantSplice(value) {
    invariant(Array.isArray(value), function () { return "update(): expected spec of $splice to be an array of arrays; got " + stringifiable(value) + ". " +
        "Did you forget to wrap your parameters in an array?"; });
}
function invariantApply(fn) {
    invariant(typeof fn === 'function', function () { return "update(): expected spec of $apply to be a function; got " + stringifiable(fn) + "."; });
}
function invariantSet(spec) {
    invariant(Object.keys(spec).length === 1, function () { return "Cannot have more than one key in an object with $set"; });
}
function invariantMerge(target, specValue) {
    invariant(specValue && typeof specValue === 'object', function () { return "update(): $merge expects a spec of type 'object'; got " + stringifiable(specValue); });
    invariant(target && typeof target === 'object', function () { return "update(): $merge expects a target of type 'object'; got " + stringifiable(target); });
}
function invariantMapOrSet(target, command) {
    var typeOfTarget = type(target);
    invariant(typeOfTarget === 'Map' || typeOfTarget === 'Set', function () { return "update(): " + stringifiable(command) + " expects a target of type Set or Map; got " + stringifiable(typeOfTarget); });
}
});

var update = unwrapExports(immutabilityHelper);
immutabilityHelper.invariant;
immutabilityHelper.Context;
immutabilityHelper.isEquals;
immutabilityHelper.extend;

const SQRT3 = Math.sqrt(3);
const axialToFlatCart = ([q, r]) => [(SQRT3 / 2) * q, (1 / 2) * q + r];
const axialToCube = ([q, r]) => [q, r, -q - r];
const cubeLen = ([q, r, s]) => (Math.abs(q) + Math.abs(r) + Math.abs(s)) / 2;
const cubeFlatNorth = [0, 1, -1];
const cubeRotate60Cv = ([q, r, s]) => [-r, -s, -q];
const cubeRotate60CvTimes = (v, times) => {
    times %= 6;
    if (times < 0)
        times += 6;
    for (let i = 0; i < times; i++)
        v = cubeRotate60Cv(v);
    return v;
};

// function readonlify<TOut, TArgs extends any[]>(
//     f: (out: TOut, ...args: TArgs) => TOut,
//     create: () => TOut
// ) {
//     return (...args: TArgs) => f(create(), ...args);
// }
function v(d) {
    const vd = {
        from: (...v) => [...v],
        zero: () => Array.from({ length: d }, () => 0),
        ones: () => Array.from({ length: d }, () => 1),
        one: (i) => Array.from({ length: d }, (_, _i) => Number(i === _i)),
        add: (a, b) => a.map((_, i) => a[i] + b[i]),
        scale: (a, b) => a.map((_, i) => a[i] * b),
        dot: (a, b) => a.map((_, i) => a[i] * b[i]).reduce((acc, v) => acc + v, 0),
        eqStrict: (a, b) => a.every((_, i) => a[i] === b[i]),
        negate: (a) => vd.scale(a, -1),
        sub: (a, b) => vd.add(a, vd.negate(b)),
        lenSq: (v) => vd.dot(v, v),
        len: (v) => Math.sqrt(vd.lenSq(v)),
        norm: (v) => vd.scale(v, 1 / vd.len(v)),
        distSq: (a, b) => vd.lenSq(vd.sub(b, a)),
        dist: (a, b) => vd.len(vd.sub(b, a)),
        eq: (a, b, eps = 0) => vd.dist(a, b) <= eps,
    };
    return vd;
}
const v3 = v(3);

function getRadiusKind(hexCubeVector) {
    const v = hexCubeVector;
    const l = cubeLen(v);
    if (l === 1) {
        return 0;
    }
    if (l === 2) {
        const hasZero = !(v[0] * v[1] * v[2]);
        return hasZero ? 1 : 2;
    }
}
const getRadiusDirection = [
    (r) => r,
    (r) => v3.scale(r, 1 / 2),
    (r) => v3.scale(v3.add(r, cubeRotate60Cv(r)), 1 / 3)
];
function isRuleAplicable(rule, source, target) {
    if (!target) {
        return rule.sourceKind === source.kind;
    }
    if (rule.sourceKind !== source.kind || rule.targetKind !== target.kind) {
        return false;
    }
    return rule.radiusKind === undefined
        ? v3.eq(target.pos, source.pos)
        : getRadiusKind(v3.sub(target.pos, source.pos)) === rule.radiusKind;
}
const calcForces = (forceRules, space) => space.map((target) => ({
    target,
    vec: space
        .flatMap((source) => {
        const r = v3.sub(target.pos, source.pos);
        const radiusKind = getRadiusKind(r);
        return forceRules
            .filter(rule => isRuleAplicable(rule, source, target))
            .map((f) => cubeRotate60CvTimes(getRadiusDirection[radiusKind](r), f.directionKind));
    })
        .reduce((sum, v) => v3.add(sum, v), [0, 0, 0])
}));
const calcProducees = (producerRules, space) => space.flatMap(token => producerRules
    .filter(r => r.sourceKind === token.kind)
    .map(r => ({ pos: token.pos, kind: r.targetKind })));
const calcConsumees = (consumerRules, space) => apply(zip3(space, space, consumerRules), pipe(filter(([source, target, rule]) => isRuleAplicable(rule, source, target)), map(([source, target, rule]) => target)));
function* forEachPair(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = i + 1; j < arr.length; j++) {
            yield [arr[i], arr[j]];
        }
    }
}
const calcStep = (ruleSet, space) => {
    const producees = [...calcProducees(ruleSet.producerRules, space)];
    const nextSpace = [...producees, ...space].map(t => _.cloneDeep(t));
    const forces = calcForces(ruleSet.forceRules, nextSpace);
    for (const force of forces) {
        force.target.pos = v3.add(force.target.pos, force.vec);
    }
    const consumees = [...calcConsumees(ruleSet.consumerRules, nextSpace)];
    const nextSpace1 = nextSpace.filter(token => consumees.indexOf(token) < 0);
    const collisions = calcCollisions(nextSpace1);
    return {
        ruleSet,
        space,
        producees,
        nextSpace,
        forces,
        consumees,
        nextSpace1,
        collisions,
    };
};
const calcCollisions = (space) => [...forEachPair(space)].filter(([t1, t2]) => v3.eq(t1.pos, t2.pos));
const simulate = (ruleSet, space) => {
    const newSpace = [
        ...calcProducees(ruleSet.producerRules, space),
        ...space.map(t => _.cloneDeep(t)),
    ];
    const forces = calcForces(ruleSet.forceRules, newSpace);
    for (const force of forces) {
        force.target.pos = v3.add(force.target.pos, force.vec);
    }
    const consumees = [...calcConsumees(ruleSet.consumerRules, newSpace)];
    return newSpace.filter(token => consumees.indexOf(token) < 0);
};

function useRxSubscribe(sourceOrSourceFactory, inputs) {
    const [state, setState] = useState();
    useEffect(() => {
        const source = ("subscribe" in sourceOrSourceFactory)
            ? sourceOrSourceFactory
            : sourceOrSourceFactory();
        const s = source.subscribe(setState);
        return () => s.unsubscribe();
    }, inputs);
    return state;
}

function* hgCircleDots(radius, center = [0, 0, 0]) {
    if (radius === 0) {
        yield center;
    }
    else {
        for (let j = 0; j < radius; j++) {
            const ps = [
                [radius, -j],
                [radius - j, -radius],
                [radius - j - 1, j + 1]
            ].map(axialToCube);
            for (const p of ps) {
                yield p;
                yield v3.negate(p);
            }
        }
    }
}
function* hgDiscDots(radius, center = [0, 0, 0]) {
    for (let i = 0; i < radius; i++) {
        yield* hgCircleDots(i, center);
    }
}

const cxy = (v) => {
    const [x, y] = axialToFlatCart(v);
    return { cx: x, cy: y };
};
const xy = (v) => {
    const [x, y] = axialToFlatCart(v);
    return { x: x, y: y };
};
const xy1 = (v) => {
    const [x, y] = axialToFlatCart(v);
    return { x1: x, y1: y };
};
const xy2 = (v) => {
    const [x, y] = axialToFlatCart(v);
    return { x2: x, y2: y };
};
const xy12 = (v1, v2) => {
    return Object.assign(Object.assign({}, xy1(v1)), xy2(v2));
};

const loop$1 = (v, cap) => (v % cap) + ((v < 0) ? cap : 0);
const addLoopUndef = (v, dv, cap) => {
    const v1 = loop$1((v !== null && v !== void 0 ? v : cap) + dv, cap + 1);
    return (v1 === cap) ? undefined : v1;
};
function TokenKindEditor({ c, value, valueCap, onInput, }) {
    return e("circle", Object.assign({ className: cx("Token", `Token${value}`) }, cxy(c), { onMouseDown: (ev) => {
            if (ev.button === 0 || ev.button === 2) {
                const dx = -(ev.button - 1);
                onInput(loop$1(value + dx, valueCap));
            }
            ev.preventDefault();
        }, onContextMenu: ev => ev.preventDefault() }));
}
function TokenKindUndefEditor({ c, value, valueCap, onInput, }) {
    return e("circle", Object.assign({ className: cx({
            "Token": value !== undefined,
            [`Token${value}`]: value !== undefined,
            "cell": value === undefined,
        }) }, cxy(c), { onMouseDown: (ev) => {
            if (ev.button === 0 || ev.button === 2) {
                const dx = -(ev.button - 1);
                onInput(addLoopUndef(value, dx, valueCap));
            }
            if (value !== undefined && ev.button === 1) {
                onInput(undefined);
            }
            ev.preventDefault();
        }, onMouseEnter: () => console.log("Mouse over coords (hex cube)", c), onContextMenu: ev => ev.preventDefault() }));
}

const loop = (v, cap) => (v % cap) + ((v < 0) ? cap : 0);
const _css$2 = css `
    & {
        height: 200px;
        border: 1px solid;
        display: block;
    }
`;
function ForceRuleEditor({ colorMap, value, onInput, }) {
    const upd = (x) => onInput(update(value, x));
    const radiusKindSet = (x) => upd({ radiusKind: { $set: x } });
    const directionKindAdd = (x) => upd({ directionKind: { $set: loop(value.directionKind + x, 6) } });
    const dots = [...hgDiscDots(3)];
    const color = colorMap[value.targetKind];
    return e("svg", Object.assign({ className: cx("ForceRuleEditor", _css$2), viewBox: "-2.7 -3.1 5.4 7.8" }, { children: [colorMap.map(color => e("marker", Object.assign({ id: `arrow_${color.substring(1)}`, viewBox: "0 -5 10 10", refX: "10", orient: "auto" }, { children: e("path", { fill: color, d: "M0,-5L10,0L0,5" }) }))), dots.map(pos => {
                if (v3.lenSq(pos) === 0) {
                    return e(TokenKindEditor, { c: pos, value: value.sourceKind, valueCap: colorMap.length, onInput: value => upd({ sourceKind: { $set: value } }) });
                }
                const rk = getRadiusKind(pos);
                if (rk === value.radiusKind) {
                    return e(TokenKindEditor, { c: pos, value: value.targetKind, valueCap: colorMap.length, onInput: value => upd({ targetKind: { $set: value } }) });
                }
                return e("circle", Object.assign({}, cxy(pos), { className: cx("cell"), onMouseDown: (ev) => {
                        if (ev.button === 0 || ev.button === 2) {
                            if (rk !== undefined) {
                                radiusKindSet(rk);
                            }
                        }
                        ev.preventDefault();
                    }, onContextMenu: ev => ev.preventDefault() }));
            }), dots.filter(pos => getRadiusKind(pos) === value.radiusKind).map(pos => {
                const color = colorMap[value.targetKind];
                const dir = getRadiusDirection[getRadiusKind(pos)](pos);
                return e("line", Object.assign({ stroke: color, "stroke-width": "0.1" }, xy12(pos, v3.add(pos, cubeRotate60CvTimes(dir, value.directionKind))), { "marker-end": `url(#arrow_${color.substring(1)})`, "pointer-events": "none" }));
            }), e("g", Object.assign({ transform: "translate(0, 3.55)" }, { children: [e("circle", { className: cx("cell"), onMouseDown: ev => {
                            if (ev.button === 0 || ev.button === 2) {
                                const dx = -(ev.button - 1);
                                directionKindAdd(dx);
                            }
                            ev.preventDefault();
                        }, onContextMenu: ev => ev.preventDefault() }), e("line", Object.assign({ stroke: color, "stroke-width": "0.1" }, xy12([0, 0], cubeRotate60CvTimes(cubeFlatNorth, value.directionKind)), { "marker-end": `url(#arrow_${color.substring(1)})`, "pointer-events": "none" }))] }))] }));
}

const ListEditorStyles = {
    boxes: css `
        & {
            display: flex;
            flex-wrap: wrap;
        }
        & .listEditorEntry {
            position: relative;
        }
        & .listEditorRemoveButton {
            position: absolute;
            top: 2px;
            right: 2px;
        }
        & .listEditorAddButton {
            padding: 30px;
        }
    `,
};
function ListEditor({ values, defaultValue, renderValueEditor, onInput, className, }) {
    const upd = (x) => onInput(update(values, x));
    return e("div", Object.assign({ className: cx("ListEditor", className) }, { children: [values.map((v, i) => e("div", Object.assign({ className: "listEditorEntry" }, { children: [renderValueEditor(v, (_0) => upd({ [i]: { $set: _0 } })), e("button", Object.assign({ className: "listEditorRemoveButton", onClick: () => upd({ $splice: [[i, 1]] }) }, { children: "\u00D7" }))] }))), e("button", Object.assign({ className: "listEditorAddButton", onClick: () => upd({ $push: [defaultValue] }) }, { children: "+" }))] }));
}

const _css$1 = css `
    & {
        height: 600px;
        border: 1px solid;
        display: block;
    }
`;
function SpaceEditor({ kindCount, value, setValue: onInput, ruleSet, }) {
    const step = calcStep(ruleSet, value);
    const upd = (x) => onInput(update(value, x));
    return e("svg", Object.assign({ className: cx("SpaceEditor", _css$1), viewBox: "-10 -10 20 20" }, { children: [apply(inf(), pipe(take(kindCount), map(i => e("marker", Object.assign({ id: `forceArrow${i}`, viewBox: "0 -5 10 10", refX: "10", orient: "auto" }, { children: e("path", { d: "M0,-5L10,0L0,5" }) }))), toArray())), "$", [...hgDiscDots(10)].map(pos => {
                var _a;
                const btnIndex = value.findIndex(b => v3.eq(b.pos, pos));
                return e(TokenKindUndefEditor, { c: pos, value: (_a = value[btnIndex]) === null || _a === void 0 ? void 0 : _a.kind, valueCap: kindCount, onInput: (newKind => {
                        if (newKind === undefined) {
                            upd({ $splice: [[btnIndex, 1]] });
                        }
                        else if (btnIndex < 0) {
                            upd({ $push: [{ kind: newKind, pos }] });
                        }
                        else {
                            upd({ [btnIndex]: { kind: { $set: newKind } } });
                        }
                    }) });
            }), "$", step.producees.map(token => e("circle", Object.assign({}, cxy(token.pos), { className: cx(`produceeToken produceeToken${token.kind}`), "pointer-events": "none" }))), "$", step.forces
                .filter(({ vec }) => v3.len(vec) > 0)
                .map(({ target, vec }) => e("line", Object.assign({ className: cx("force", "force" + target.kind) }, xy12(v3.sub(target.pos, vec), target.pos), { "pointer-events": "none" }))), "$", step.consumees.map(token => e("circle", Object.assign({}, cxy(token.pos), { className: cx(`consumeeToken consumeeToken${token.kind}`), "pointer-events": "none" }))), "$", step.collisions.map(collision => e(Fragment, { children: e("text", Object.assign({}, xy(collision[0].pos), { "font-size": "0.4px", "pointer-events": "none" }, { children: [". Collision: ", JSON.stringify(collision)] })) }))] }));
}

function FramePlayer({ value: t, setValue: setT, }) {
    const [isTicking, setIsTicking] = useState(false);
    const autoplayT = useRxSubscribe(() => isTicking
        ? rx.timer(100, 500).pipe(rx.map(i => t + i + 1))
        : rx.from([undefined]), [isTicking]);
    if (isTicking && autoplayT !== undefined && autoplayT !== t) {
        setT(autoplayT);
    }
    return e("div", Object.assign({ className: cx("FramePlayer") }, { children: [e("button", Object.assign({ onClick: () => { setIsTicking(false); setT(0); } }, { children: "\u23F9" })), e("button", Object.assign({ onClick: () => { setIsTicking(false); setT(Math.max(t - 1, 0)); } }, { children: "\u2759\u23F4" })), e("button", Object.assign({ onClick: () => { setIsTicking(!isTicking); } }, { children: isTicking ? e(Fragment, { children: "\u23F8" }) : e(Fragment, { children: "\u25B6" }) })), e("button", Object.assign({ onClick: () => { setIsTicking(false); setT(t + 1); } }, { children: "\u23F5\u2759" })), e("span", { children: [" Step: ", t + 1] })] }));
}

const levelSetup1 = {
    ruleSet: {
        forceRules: [
            { sourceKind: 1, targetKind: 0, radiusKind: 1, directionKind: 2 },
            { sourceKind: 1, targetKind: 0, radiusKind: 2, directionKind: 1 }
        ],
        producerRules: [
            { sourceKind: 2, targetKind: 0 }
        ],
        consumerRules: [
            { sourceKind: 3, targetKind: 0 }
        ],
    },
    initialSpace: [
        { kind: 2, pos: [0, 0, 0] },
        { kind: 1, pos: [-2, 0, 2] },
        { kind: 1, pos: [-3, -1, 4] },
        { kind: 3, pos: [-1, -2, 3] },
    ],
};

const sim = (...args) => apply(inf(), pipe(scan(s => simulate(args[0], s), args[1]), tap(console.log)));
const ensureTime = (spacetime, t, ruleSet) => {
    if (t < spacetime.length) {
        return spacetime;
    }
    return [
        ...apply(concat(spacetime, sim(ruleSet, _.last(spacetime))), take(t + 1)),
    ];
};
const noop = () => undefined;
const colors = ["#ff0000", "#00ff00", "#0000ff", "#ffff00", "#00ffff", "#ff00ff"];
const _css = css `
    & {
        background-color: #efe;
    }
    &.playing {
        background-color: #eef;
    }
    &>h1 {
        color: #4f4;
        line-height: 1.5em;
    }
    &.playing>h1 {
        color: #44f;
    }
    & .Token, & .cell {
        stroke: black;
        stroke-width: 0.01px;
        r: 0.3px;
    }
    & .cell {
        fill: transparent;
    }
    & .force {
        stroke-width: 0.1px;
    }
    & .produceeToken {
        r: 0.18px;
    }
    & .consumeeToken {
        r: 0.18px;
        stroke-width: 0.04px;
        fill: transparent;
    }
    ${colors.map((color, i) => /*css*/ `
        & .Token${i} {
            fill: ${color};
        }
        & #forceArrow${i} path {
            fill: ${color};
        }
        & .force${i} {
            stroke: ${color};
            marker-end: url(#forceArrow${i})
        }
        & .produceeToken${i} {
            fill: ${color};
        }
        & .consumeeToken${i} {
            stroke: ${color};
        }
    `).join("")}
`;
function App() {
    const colorMap = colors;
    const [ruleSet, setRuleSet] = useState(levelSetup1.ruleSet);
    const [initialSpace, setInitialState] = useState(levelSetup1.initialSpace);
    const [{ spacetime, t }, setState] = useState(() => ({
        spacetime: [initialSpace],
        t: 0,
    }));
    useEffect(() => {
        setState({
            spacetime: [initialSpace],
            t: 0,
        });
    }, [initialSpace, ruleSet]);
    const setT = (t) => setState(({ spacetime }) => ({
        spacetime: ensureTime(spacetime, t, ruleSet),
        t,
    }));
    const isEditor = t === 0;
    const space = spacetime[t];
    const step = calcStep(ruleSet, space);
    const [setupString, setSetupString] = useState(JSON.stringify({
        ruleSet,
        initialSpace,
    }));
    return e("div", Object.assign({ className: cx("App", { playing: !isEditor }, _css) }, { children: [e("h1", { children: isEditor
                    ? e(Fragment, { children: "Editor mode: can edit" })
                    : e(Fragment, { children: "Player mode: reset \u23F9 player to first step to edit" }) }), e(ListEditor, { values: ruleSet.forceRules, defaultValue: {
                    sourceKind: 0,
                    targetKind: 1,
                    radiusKind: 1,
                    directionKind: 0
                }, renderValueEditor: (v, onInput) => e(ForceRuleEditor, { colorMap: colorMap, value: v, onInput: onInput }), onInput: (forceRules) => setRuleSet(ruleSet => update(ruleSet, { forceRules: { $set: forceRules } })), className: ListEditorStyles.boxes }), e("div", { children: ["producerRules: ", JSON.stringify(ruleSet.producerRules)] }), e("div", { children: ["consumerRules: ", JSON.stringify(ruleSet.consumerRules)] }), e(FramePlayer, { value: t, setValue: setT }), e(SpaceEditor, { kindCount: colorMap.length, value: space, setValue: isEditor ? setInitialState : noop, ruleSet: ruleSet }), step.collisions.length > 0 && e("div", Object.assign({ style: { color: "red" } }, { children: ["Has collisions: ", JSON.stringify(step.collisions.map(([{ pos }]) => pos))] })), e("button", Object.assign({ onClick: () => {
                    setSetupString(JSON.stringify({
                        ruleSet,
                        initialSpace,
                    }));
                } }, { children: "Update setup string" })), e("input", { value: setupString, onInput: ev => setSetupString((ev.target).value) }), e("button", Object.assign({ onClick: () => __awaiter(this, void 0, void 0, function* () {
                    const setup = JSON.parse(setupString);
                    setRuleSet(setup.ruleSet);
                    setInitialState(setup.initialSpace);
                }) }, { children: "Parse setup string" })), e("div", { children: useRxSubscribe(() => rx.interval(20).pipe(rx.map(() => new Date().toISOString())), []) })] }));
}

render(e(App, {}), document.body);
</script>
</body>
</html>