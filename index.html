<!DOCTYPE html><html lang="en">
<head><title>pull-push-puzzle</title></head>
<body>
    <script async src="https://unpkg.com/es-module-shims@1.5.5/dist/es-module-shims.js"></script>
    <script type="importmap">{"imports":{"lodash":"https://unpkg.com/@esm-bundle/lodash@4.17.21/esm/index.js","rxjs":"https://unpkg.com/@esm-bundle/rxjs@7.5.5/esm/es2015/rxjs.min.js","preact":"https://unpkg.com/preact@10.7.2/dist/preact.mjs","preact/hooks":"https://unpkg.com/preact@10.7.2/hooks/dist/hooks.mjs","@emotion/css":"https://unpkg.com/@esm-bundle/emotion@10.0.27/esm/emotion.min.js"}}</script>
    <link rel="modulepreload" href="https://unpkg.com/@esm-bundle/lodash@4.17.21/esm/index.js"/>
<link rel="modulepreload" href="https://unpkg.com/@esm-bundle/rxjs@7.5.5/esm/es2015/rxjs.min.js"/>
<link rel="modulepreload" href="https://unpkg.com/preact@10.7.2/dist/preact.mjs"/>
<link rel="modulepreload" href="https://unpkg.com/preact@10.7.2/hooks/dist/hooks.mjs"/>
<link rel="modulepreload" href="https://unpkg.com/@esm-bundle/emotion@10.0.27/esm/emotion.min.js"/>
    <script type="module">import { options, Fragment, Component, render } from 'preact';
import { css, cx } from '@emotion/css';
import * as rx from 'rxjs';
import * as _ from 'lodash';
import { useState, useEffect } from 'preact/hooks';

var o$1=0;function e(_,e,n,t,f){var l,s,u={};for(s in e)"ref"==s?l=e[s]:u[s]=e[s];var a={type:_,props:u,key:n,ref:l,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:--o$1,__source:f,__self:t};if("function"==typeof _&&(l=_.defaultProps))for(s in l)void 0===u[s]&&(u[s]=l[s]);return options.vnode&&options.vnode(a),a}

"undefined"!=typeof window&&window.__PREACT_DEVTOOLS__&&window.__PREACT_DEVTOOLS__.attachPreact("10.7.2",options,{Fragment:Fragment,Component:Component});

var o={};function a(n){return n.type===Fragment?"Fragment":"function"==typeof n.type?n.type.displayName||n.type.name:"string"==typeof n.type?n.type:"#text"}var i=[],s=[];function c(){return i.length>0?i[i.length-1]:null}var l=!1;function u(n){return "function"==typeof n.type&&n.type!=Fragment}function f(n){for(var t=[n],e=n;null!=e.__o;)t.push(e.__o),e=e.__o;return t.reduce(function(n,t){n+="  in "+a(t);var e=t.__source;return e?n+=" (at "+e.fileName+":"+e.lineNumber+")":l||(l=!0,console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")),n+"\n"},"")}var p="function"==typeof WeakMap,d=Component.prototype.setState;Component.prototype.setState=function(n,t){return null==this.__v?null==this.state&&console.warn('Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n'+f(c())):null==this.__P&&console.warn('Can\'t call "this.setState" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n'+f(this.__v)),d.call(this,n,t)};var h=Component.prototype.forceUpdate;function y(n){var t=n.props,e=a(n),o="";for(var r in t)if(t.hasOwnProperty(r)&&"children"!==r){var i=t[r];"function"==typeof i&&(i="function "+(i.displayName||i.name)+"() {}"),i=Object(i)!==i||i.toString?i+"":Object.prototype.toString.call(i),o+=" "+r+"="+JSON.stringify(i);}var s=t.children;return "<"+e+o+(s&&s.length?">..</"+e+">":" />")}Component.prototype.forceUpdate=function(n){return null==this.__v?console.warn('Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n'+f(c())):null==this.__P&&console.warn('Can\'t call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n'+f(this.__v)),h.call(this,n)},function(){!function(){var t=options.__b,e=options.diffed,o=options.__,r=options.vnode,a=options.__r;options.diffed=function(n){u(n)&&s.pop(),i.pop(),e&&e(n);},options.__b=function(n){u(n)&&i.push(n),t&&t(n);},options.__=function(n,t){s=[],o&&o(n,t);},options.vnode=function(n){n.__o=s.length>0?s[s.length-1]:null,r&&r(n);},options.__r=function(n){u(n)&&s.push(n),a&&a(n);};}();var t=!1,e=options.__b,r=options.diffed,c=options.vnode,l=options.__e,d=options.__,h=options.__h,m=p?{useEffect:new WeakMap,useLayoutEffect:new WeakMap,lazyPropTypes:new WeakMap}:null,v=[];options.__e=function(n,t,e,o){if(t&&t.__c&&"function"==typeof n.then){var r=n;n=new Error("Missing Suspense. The throwing component was: "+a(t));for(var i=t;i;i=i.__)if(i.__c&&i.__c.__c){n=r;break}if(n instanceof Error)throw n}try{(o=o||{}).componentStack=f(t),l(n,t,e,o),"function"!=typeof n.then&&setTimeout(function(){throw n});}catch(n){throw n}},options.__=function(n,t){if(!t)throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");var e;switch(t.nodeType){case 1:case 11:case 9:e=!0;break;default:e=!1;}if(!e){var o=a(n);throw new Error("Expected a valid HTML node as a second argument to render.\tReceived "+t+" instead: render(<"+o+" />, "+t+");")}d&&d(n,t);},options.__b=function(n){var r=n.type,i=function n(t){return t?"function"==typeof t.type?n(t.__):t:{}}(n.__);if(t=!0,void 0===r)throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports"+y(n)+"\n\n"+f(n));if(null!=r&&"object"==typeof r){if(void 0!==r.__k&&void 0!==r.__e)throw new Error("Invalid type passed to createElement(): "+r+"\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My"+a(n)+" = "+y(r)+";\n  let vnode = <My"+a(n)+" />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n"+f(n));throw new Error("Invalid type passed to createElement(): "+(Array.isArray(r)?"array":r))}if("thead"!==r&&"tfoot"!==r&&"tbody"!==r||"table"===i.type?"tr"===r&&"thead"!==i.type&&"tfoot"!==i.type&&"tbody"!==i.type&&"table"!==i.type?console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent."+y(n)+"\n\n"+f(n)):"td"===r&&"tr"!==i.type?console.error("Improper nesting of table. Your <td> should have a <tr> parent."+y(n)+"\n\n"+f(n)):"th"===r&&"tr"!==i.type&&console.error("Improper nesting of table. Your <th> should have a <tr>."+y(n)+"\n\n"+f(n)):console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent."+y(n)+"\n\n"+f(n)),void 0!==n.ref&&"function"!=typeof n.ref&&"object"!=typeof n.ref&&!("$$typeof"in n))throw new Error('Component\'s "ref" property should be a function, or an object created by createRef(), but got ['+typeof n.ref+"] instead\n"+y(n)+"\n\n"+f(n));if("string"==typeof n.type)for(var s in n.props)if("o"===s[0]&&"n"===s[1]&&"function"!=typeof n.props[s]&&null!=n.props[s])throw new Error("Component's \""+s+'" property should be a function, but got ['+typeof n.props[s]+"] instead\n"+y(n)+"\n\n"+f(n));if("function"==typeof n.type&&n.type.propTypes){if("Lazy"===n.type.displayName&&m&&!m.lazyPropTypes.has(n.type)){var c="PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";try{var l=n.type();m.lazyPropTypes.set(n.type,!0),console.warn(c+"Component wrapped in lazy() is "+a(l));}catch(n){console.warn(c+"We will log the wrapped component's name once it is loaded.");}}var u=n.props;n.type.__f&&delete(u=function(n,t){for(var e in t)n[e]=t[e];return n}({},u)).ref,function(n,t,e,r,a){Object.keys(n).forEach(function(e){var i;try{i=n[e](t,e,r,"prop",null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");}catch(n){i=n;}!i||i.message in o||(o[i.message]=!0,console.error("Failed prop type: "+i.message+(a&&"\n"+a()||"")));});}(n.type.propTypes,u,0,a(n),function(){return f(n)});}e&&e(n);},options.__h=function(n,e,o){if(!n||!t)throw new Error("Hook can only be invoked from render methods.");h&&h(n,e,o);};var b=function(n,t){return {get:function(){var e="get"+n+t;v&&v.indexOf(e)<0&&(v.push(e),console.warn("getting vnode."+n+" is deprecated, "+t));},set:function(){var e="set"+n+t;v&&v.indexOf(e)<0&&(v.push(e),console.warn("setting vnode."+n+" is not allowed, "+t));}}},w={nodeName:b("nodeName","use vnode.type"),attributes:b("attributes","use vnode.props"),children:b("children","use vnode.props.children")},g=Object.create({},w);options.vnode=function(n){var t=n.props;if(null!==n.type&&null!=t&&("__source"in t||"__self"in t)){var e=n.props={};for(var o in t){var r=t[o];"__source"===o?n.__source=r:"__self"===o?n.__self=r:e[o]=r;}}n.__proto__=g,c&&c(n);},options.diffed=function(n){if(n.__k&&n.__k.forEach(function(t){if(t&&void 0===t.type){delete t.__,delete t.__b;var e=Object.keys(t).join(",");throw new Error("Objects are not valid as a child. Encountered an object with the keys {"+e+"}.\n\n"+f(n))}}),t=!1,r&&r(n),null!=n.__k)for(var e=[],o=0;o<n.__k.length;o++){var a=n.__k[o];if(a&&null!=a.key){var i=a.key;if(-1!==e.indexOf(i)){console.error('Following component has two or more children with the same key attribute: "'+i+'". This may cause glitches and misbehavior in rendering process. Component: \n\n'+y(n)+"\n\n"+f(n));break}e.push(i);}}};}();

const SQRT3 = Math.sqrt(3);
const axialToFlatCart = ([q, r]) => [(SQRT3 / 2) * q, (1 / 2) * q + r];
const axialToCube = ([q, r]) => [q, r, -q - r];
const cubeLen = ([q, r, s]) => (Math.abs(q) + Math.abs(r) + Math.abs(s)) / 2;
const cubeFlatNorth = [0, 1, -1];
const cubeRotate60Cv = ([q, r, s]) => [-r, -s, -q];
const cubeRotate60CvTimes = (v, times) => {
    times %= 6;
    if (times < 0)
        times += 6;
    for (let i = 0; i < times; i++)
        v = cubeRotate60Cv(v);
    return v;
};

// function readonlify<TOut, TArgs extends any[]>(
//     f: (out: TOut, ...args: TArgs) => TOut,
//     create: () => TOut
// ) {
//     return (...args: TArgs) => f(create(), ...args);
// }
function v(d) {
    const vd = {
        from: (...v) => [...v],
        zero: () => Array.from({ length: d }, () => 0),
        ones: () => Array.from({ length: d }, () => 1),
        one: (i) => Array.from({ length: d }, (_, _i) => Number(i === _i)),
        add: (a, b) => a.map((_, i) => a[i] + b[i]),
        scale: (a, b) => a.map((_, i) => a[i] * b),
        dot: (a, b) => a.map((_, i) => a[i] * b[i]).reduce((acc, v) => acc + v, 0),
        eqStrict: (a, b) => a.every((_, i) => a[i] === b[i]),
        negate: (a) => vd.scale(a, -1),
        sub: (a, b) => vd.add(a, vd.negate(b)),
        lenSq: (v) => vd.dot(v, v),
        len: (v) => Math.sqrt(vd.lenSq(v)),
        norm: (v) => vd.scale(v, 1 / vd.len(v)),
        distSq: (a, b) => vd.lenSq(vd.sub(b, a)),
        dist: (a, b) => vd.len(vd.sub(b, a)),
        eq: (a, b, eps = 0) => vd.dist(a, b) <= eps,
    };
    return vd;
}
const v3 = v(3);

function getRadiusKind(hexCubeVector) {
    const v = hexCubeVector;
    const l = cubeLen(v);
    if (l === 1) {
        return 0;
    }
    if (l === 2) {
        const hasZero = !(v[0] * v[1] * v[2]);
        return hasZero ? 1 : 2;
    }
}
const getRadiusDirection = [
    (r) => r,
    (r) => v3.scale(r, 1 / 2),
    (r) => v3.scale(v3.add(r, cubeRotate60Cv(r)), 1 / 3)
];
const calcForces = (forceRules, buttons) => buttons.map((target) => ({
    target,
    vec: buttons
        .flatMap((source) => {
        const r = v3.sub(target.pos, source.pos);
        const radiusKind = getRadiusKind(r);
        return forceRules
            .filter((f) => f.sourceKind === source.kind &&
            f.targetKind === target.kind &&
            f.radiusKind === radiusKind)
            .map((f) => cubeRotate60CvTimes(getRadiusDirection[radiusKind](r), f.directionKind));
    })
        .reduce((sum, v) => v3.add(sum, v), [0, 0, 0])
}));
const simulate = (forceRules, space) => {
    const newSpace = _.cloneDeep(space);
    const forces = calcForces(forceRules, newSpace);
    for (const force of forces) {
        force.target.pos = v3.add(force.target.pos, force.vec);
    }
    return newSpace;
};

function useRxSubscribe(sourceOrSourceFactory, inputs) {
    const [state, setState] = useState();
    useEffect(() => {
        const source = ("subscribe" in sourceOrSourceFactory)
            ? sourceOrSourceFactory
            : sourceOrSourceFactory();
        const s = source.subscribe(setState);
        return () => s.unsubscribe();
    }, inputs);
    return state;
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function HgCircle(_a) {
    var { c, children } = _a, props = __rest(_a, ["c", "children"]);
    const [cx, cy] = axialToFlatCart(c);
    return e("circle", Object.assign({ cx: cx, cy: cy }, props, { children: children }));
}
function HgLine(_a) {
    var { p1, p2, children } = _a, props = __rest(_a, ["p1", "p2", "children"]);
    const [x1, y1] = axialToFlatCart(p1);
    const [x2, y2] = axialToFlatCart(p2);
    return e("line", Object.assign({ x1: x1, y1: y1, x2: x2, y2: y2 }, props, { children: children }));
}

function* hgCircleDots(radius, center = [0, 0, 0]) {
    if (radius === 0) {
        yield center;
    }
    else {
        for (let j = 0; j < radius; j++) {
            const ps = [
                [radius, -j],
                [radius - j, -radius],
                [radius - j - 1, j + 1]
            ].map(axialToCube);
            for (const p of ps) {
                yield p;
                yield v3.negate(p);
            }
        }
    }
}
function* hgDiscDots(radius, center = [0, 0, 0]) {
    for (let i = 0; i < radius; i++) {
        yield* hgCircleDots(i, center);
    }
}
function ButtonView({ colorMap, kind, hpos, }) {
    const [cx, cy] = axialToFlatCart(hpos);
    return e("circle", { cx: cx, cy: cy, r: "0.5", fill: colorMap[kind] });
}
const _css$3 = css `
    & svg {
        height: 600px;
        border: 1px solid;
    }
`;
function SimulationPlayer({ spacetime, colorMap, forceRules, }) {
    const [t, setT] = useState(0);
    const incT = () => setT((t + 1) % spacetime.length);
    const decT = () => setT((t + spacetime.length - 1) % spacetime.length);
    const space = spacetime[t];
    return e("div", Object.assign({ className: cx("SimulationPlayer", _css$3) }, { children: [e("svg", Object.assign({ viewBox: "-15 -15 30 30" }, { children: [colorMap.map(color => e("marker", Object.assign({ id: `arrow_${color.substring(1)}`, viewBox: "0 -5 10 10", refX: "10", orient: "auto" }, { children: e("path", { fill: color, d: "M0,-5L10,0L0,5" }) }))), "$", [...hgDiscDots(30)].map(dot => e(HgCircle, { c: dot, r: "0.05" })), "$", space.map(({ kind, pos }) => e(ButtonView, { colorMap: colorMap, kind: kind, hpos: pos })), "$", calcForces(forceRules, space)
                        .filter(({ vec }) => v3.len(vec) > 0)
                        .map(({ target, vec }) => {
                        const color = colorMap[target.kind];
                        return e(HgLine, { stroke: color, "stroke-width": "0.1", p1: target.pos, p2: v3.add(target.pos, vec), "marker-end": `url(#arrow_${color.substring(1)})` });
                    })] })), e("div", { children: [e("span", { children: ["Step: ", t + 1, " / ", spacetime.length] }), ".....", e("button", Object.assign({ onClick: () => setT(0) }, { children: "0" })), e("button", Object.assign({ onClick: decT }, { children: "<" })), e("button", Object.assign({ onClick: incT }, { children: ">" }))] })] }));
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var immutabilityHelper = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
function stringifiable(obj) {
    // Safely stringify Object.create(null)
    /* istanbul ignore next */
    return typeof obj === 'object' && !('toString' in obj) ?
        Object.prototype.toString.call(obj).slice(8, -1) :
        obj;
}
var isProduction = typeof process === 'object' && process.env.NODE_ENV === 'production';
function invariant(condition, message) {
    if (!condition) {
        /* istanbul ignore next */
        if (isProduction) {
            throw new Error('Invariant failed');
        }
        throw new Error(message());
    }
}
exports.invariant = invariant;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var splice = Array.prototype.splice;
var toString = Object.prototype.toString;
function type(obj) {
    return toString.call(obj).slice(8, -1);
}
var assign = Object.assign || /* istanbul ignore next */ (function (target, source) {
    getAllKeys(source).forEach(function (key) {
        if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
        }
    });
    return target;
});
var getAllKeys = typeof Object.getOwnPropertySymbols === 'function'
    ? function (obj) { return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)); }
    /* istanbul ignore next */
    : function (obj) { return Object.keys(obj); };
function copy(object) {
    return Array.isArray(object)
        ? assign(object.constructor(object.length), object)
        : (type(object) === 'Map')
            ? new Map(object)
            : (type(object) === 'Set')
                ? new Set(object)
                : (object && typeof object === 'object')
                    ? assign(Object.create(Object.getPrototypeOf(object)), object)
                    /* istanbul ignore next */
                    : object;
}
var Context = /** @class */ (function () {
    function Context() {
        this.commands = assign({}, defaultCommands);
        this.update = this.update.bind(this);
        // Deprecated: update.extend, update.isEquals and update.newContext
        this.update.extend = this.extend = this.extend.bind(this);
        this.update.isEquals = function (x, y) { return x === y; };
        this.update.newContext = function () { return new Context().update; };
    }
    Object.defineProperty(Context.prototype, "isEquals", {
        get: function () {
            return this.update.isEquals;
        },
        set: function (value) {
            this.update.isEquals = value;
        },
        enumerable: true,
        configurable: true
    });
    Context.prototype.extend = function (directive, fn) {
        this.commands[directive] = fn;
    };
    Context.prototype.update = function (object, $spec) {
        var _this = this;
        var spec = (typeof $spec === 'function') ? { $apply: $spec } : $spec;
        if (!(Array.isArray(object) && Array.isArray(spec))) {
            invariant(!Array.isArray(spec), function () { return "update(): You provided an invalid spec to update(). The spec may " +
                "not contain an array except as the value of $set, $push, $unshift, " +
                "$splice or any custom command allowing an array value."; });
        }
        invariant(typeof spec === 'object' && spec !== null, function () { return "update(): You provided an invalid spec to update(). The spec and " +
            "every included key path must be plain objects containing one of the " +
            ("following commands: " + Object.keys(_this.commands).join(', ') + "."); });
        var nextObject = object;
        getAllKeys(spec).forEach(function (key) {
            if (hasOwnProperty.call(_this.commands, key)) {
                var objectWasNextObject = object === nextObject;
                nextObject = _this.commands[key](spec[key], nextObject, spec, object);
                if (objectWasNextObject && _this.isEquals(nextObject, object)) {
                    nextObject = object;
                }
            }
            else {
                var nextValueForKey = type(object) === 'Map'
                    ? _this.update(object.get(key), spec[key])
                    : _this.update(object[key], spec[key]);
                var nextObjectValue = type(nextObject) === 'Map'
                    ? nextObject.get(key)
                    : nextObject[key];
                if (!_this.isEquals(nextValueForKey, nextObjectValue)
                    || typeof nextValueForKey === 'undefined'
                        && !hasOwnProperty.call(object, key)) {
                    if (nextObject === object) {
                        nextObject = copy(object);
                    }
                    if (type(nextObject) === 'Map') {
                        nextObject.set(key, nextValueForKey);
                    }
                    else {
                        nextObject[key] = nextValueForKey;
                    }
                }
            }
        });
        return nextObject;
    };
    return Context;
}());
exports.Context = Context;
var defaultCommands = {
    $push: function (value, nextObject, spec) {
        invariantPushAndUnshift(nextObject, spec, '$push');
        return value.length ? nextObject.concat(value) : nextObject;
    },
    $unshift: function (value, nextObject, spec) {
        invariantPushAndUnshift(nextObject, spec, '$unshift');
        return value.length ? value.concat(nextObject) : nextObject;
    },
    $splice: function (value, nextObject, spec, originalObject) {
        invariantSplices(nextObject, spec);
        value.forEach(function (args) {
            invariantSplice(args);
            if (nextObject === originalObject && args.length) {
                nextObject = copy(originalObject);
            }
            splice.apply(nextObject, args);
        });
        return nextObject;
    },
    $set: function (value, _nextObject, spec) {
        invariantSet(spec);
        return value;
    },
    $toggle: function (targets, nextObject) {
        invariantSpecArray(targets, '$toggle');
        var nextObjectCopy = targets.length ? copy(nextObject) : nextObject;
        targets.forEach(function (target) {
            nextObjectCopy[target] = !nextObject[target];
        });
        return nextObjectCopy;
    },
    $unset: function (value, nextObject, _spec, originalObject) {
        invariantSpecArray(value, '$unset');
        value.forEach(function (key) {
            if (Object.hasOwnProperty.call(nextObject, key)) {
                if (nextObject === originalObject) {
                    nextObject = copy(originalObject);
                }
                delete nextObject[key];
            }
        });
        return nextObject;
    },
    $add: function (values, nextObject, _spec, originalObject) {
        invariantMapOrSet(nextObject, '$add');
        invariantSpecArray(values, '$add');
        if (type(nextObject) === 'Map') {
            values.forEach(function (_a) {
                var key = _a[0], value = _a[1];
                if (nextObject === originalObject && nextObject.get(key) !== value) {
                    nextObject = copy(originalObject);
                }
                nextObject.set(key, value);
            });
        }
        else {
            values.forEach(function (value) {
                if (nextObject === originalObject && !nextObject.has(value)) {
                    nextObject = copy(originalObject);
                }
                nextObject.add(value);
            });
        }
        return nextObject;
    },
    $remove: function (value, nextObject, _spec, originalObject) {
        invariantMapOrSet(nextObject, '$remove');
        invariantSpecArray(value, '$remove');
        value.forEach(function (key) {
            if (nextObject === originalObject && nextObject.has(key)) {
                nextObject = copy(originalObject);
            }
            nextObject.delete(key);
        });
        return nextObject;
    },
    $merge: function (value, nextObject, _spec, originalObject) {
        invariantMerge(nextObject, value);
        getAllKeys(value).forEach(function (key) {
            if (value[key] !== nextObject[key]) {
                if (nextObject === originalObject) {
                    nextObject = copy(originalObject);
                }
                nextObject[key] = value[key];
            }
        });
        return nextObject;
    },
    $apply: function (value, original) {
        invariantApply(value);
        return value(original);
    },
};
var defaultContext = new Context();
exports.isEquals = defaultContext.update.isEquals;
exports.extend = defaultContext.extend;
exports.default = defaultContext.update;
// @ts-ignore
exports.default.default = module.exports = assign(exports.default, exports);
// invariants
function invariantPushAndUnshift(value, spec, command) {
    invariant(Array.isArray(value), function () { return "update(): expected target of " + stringifiable(command) + " to be an array; got " + stringifiable(value) + "."; });
    invariantSpecArray(spec[command], command);
}
function invariantSpecArray(spec, command) {
    invariant(Array.isArray(spec), function () { return "update(): expected spec of " + stringifiable(command) + " to be an array; got " + stringifiable(spec) + ". " +
        "Did you forget to wrap your parameter in an array?"; });
}
function invariantSplices(value, spec) {
    invariant(Array.isArray(value), function () { return "Expected $splice target to be an array; got " + stringifiable(value); });
    invariantSplice(spec.$splice);
}
function invariantSplice(value) {
    invariant(Array.isArray(value), function () { return "update(): expected spec of $splice to be an array of arrays; got " + stringifiable(value) + ". " +
        "Did you forget to wrap your parameters in an array?"; });
}
function invariantApply(fn) {
    invariant(typeof fn === 'function', function () { return "update(): expected spec of $apply to be a function; got " + stringifiable(fn) + "."; });
}
function invariantSet(spec) {
    invariant(Object.keys(spec).length === 1, function () { return "Cannot have more than one key in an object with $set"; });
}
function invariantMerge(target, specValue) {
    invariant(specValue && typeof specValue === 'object', function () { return "update(): $merge expects a spec of type 'object'; got " + stringifiable(specValue); });
    invariant(target && typeof target === 'object', function () { return "update(): $merge expects a target of type 'object'; got " + stringifiable(target); });
}
function invariantMapOrSet(target, command) {
    var typeOfTarget = type(target);
    invariant(typeOfTarget === 'Map' || typeOfTarget === 'Set', function () { return "update(): " + stringifiable(command) + " expects a target of type Set or Map; got " + stringifiable(typeOfTarget); });
}
});

var update = unwrapExports(immutabilityHelper);
immutabilityHelper.invariant;
immutabilityHelper.Context;
immutabilityHelper.isEquals;
immutabilityHelper.extend;

const loop = (v, cap) => (v % cap) + ((v < 0) ? cap : 0);
const _css$2 = css `
    & {
        height: 200px;
        border: 1px solid;
        display: block;
    }
`;
function ForceRuleEditor({ colorMap, value, onInput, }) {
    const upd = (x) => onInput(update(value, x));
    const sourceKindAdd = (x) => upd({ sourceKind: { $set: loop(value.sourceKind + x, colorMap.length) } });
    const targetKindAdd = (x) => upd({ targetKind: { $set: loop(value.targetKind + x, colorMap.length) } });
    const radiusKindSet = (x) => upd({ radiusKind: { $set: x } });
    const directionKindAdd = (x) => upd({ directionKind: { $set: loop(value.directionKind + x, 6) } });
    const dots = [...hgDiscDots(3)];
    const color = colorMap[value.targetKind];
    return e("svg", Object.assign({ className: cx("ForceRuleEditor", _css$2), viewBox: "-2.7 -2.7 7.4 5.4" }, { children: [colorMap.map(color => e("marker", Object.assign({ id: `arrow_${color.substring(1)}`, viewBox: "0 -5 10 10", refX: "10", orient: "auto" }, { children: e("path", { fill: color, d: "M0,-5L10,0L0,5" }) }))), dots.map(pos => {
                const fill = (v3.len(pos) === 0 && colorMap[value.sourceKind]) ||
                    (getRadiusKind(pos) === value.radiusKind && colorMap[value.targetKind]) ||
                    "white";
                const onMouseDown = (ev) => {
                    if (ev.button === 0 || ev.button === 2) {
                        const dx = -(ev.button - 1);
                        if (v3.len(pos) === 0) {
                            sourceKindAdd(dx);
                        }
                        else {
                            const rk = getRadiusKind(pos);
                            if (rk === value.radiusKind) {
                                targetKindAdd(dx);
                            }
                            else {
                                if (rk !== undefined) {
                                    radiusKindSet(rk);
                                }
                            }
                        }
                    }
                    ev.preventDefault();
                };
                return e(HgCircle, { c: pos, fill: fill, onMouseDown: onMouseDown, onContextMenu: ev => ev.preventDefault(), stroke: "black", "stroke-width": "0.01", r: "0.3" });
            }), dots.filter(pos => getRadiusKind(pos) === value.radiusKind).map(pos => {
                const color = colorMap[value.targetKind];
                const dir = getRadiusDirection[getRadiusKind(pos)](pos);
                return e(HgLine, { stroke: color, "stroke-width": "0.1", p1: pos, p2: v3.add(pos, cubeRotate60CvTimes(dir, value.directionKind)), "marker-end": `url(#arrow_${color.substring(1)})`, "pointer-events": "none" });
            }), e("g", Object.assign({ transform: "translate(3.35)" }, { children: [e("circle", { fill: "white", stroke: "black", "stroke-width": "0.01", r: "0.3", onMouseDown: ev => {
                            if (ev.button === 0 || ev.button === 2) {
                                const dx = -(ev.button - 1);
                                directionKindAdd(dx);
                            }
                            ev.preventDefault();
                        }, onContextMenu: ev => ev.preventDefault() }), e(HgLine, { stroke: color, "stroke-width": "0.1", p1: [0, 0], p2: cubeRotate60CvTimes(cubeFlatNorth, value.directionKind), "marker-end": `url(#arrow_${color.substring(1)})`, "pointer-events": "none" })] }))] }));
}

const createStateUpdater = (setState) => ($spec) => setState(prev => update(prev, $spec));
function useState1(initialState) {
    const [state, setState] = useState(initialState);
    return [state, setState, createStateUpdater(setState)];
}

const ListEditorStyles = {
    boxes: css `
        & {
            display: flex;
            flex-wrap: wrap;
        }
        & .listEditorEntry {
            position: relative;
        }
        & .listEditorRemoveButton {
            position: absolute;
            top: 2px;
            right: 2px;
        }
        & .listEditorAddButton {
            padding: 30px;
        }
    `,
};
function ListEditor({ values, defaultValue, renderValueEditor, onInput, className, }) {
    const upd = (x) => onInput(update(values, x));
    return e("div", Object.assign({ className: cx("ListEditor", className) }, { children: [values.map((v, i) => e("div", Object.assign({ className: "listEditorEntry" }, { children: [renderValueEditor(v, (_0) => upd({ [i]: { $set: _0 } })), e("button", Object.assign({ className: "listEditorRemoveButton", onClick: () => upd({ $splice: [[i, 1]] }) }, { children: "\u00D7" }))] }))), e("button", Object.assign({ className: "listEditorAddButton", onClick: () => upd({ $push: [defaultValue] }) }, { children: "+" }))] }));
}

function* inf() { for (let i = 0; true; i++) {
    yield i;
} }
function* pipe(iterable, op) {
    let subscriber;
    let pool = [];
    new rx.Observable(s => subscriber = s)
        .pipe(op)
        .subscribe(v => pool.push(v));
    for (const value of iterable) {
        subscriber.next(value);
        yield* pool;
        if (subscriber.closed) {
            return;
        }
        pool = [];
    }
    subscriber.complete();
}

const _css$1 = css `
    & {
        height: 600px;
        border: 1px solid;
        display: block;
    }
`;
function SpaceEditor({ colorMap, value, onInput, forceRules, }) {
    const upd = (x) => onInput(update(value, x));
    const loop = (v, cap) => (v % cap) + ((v < 0) ? cap : 0);
    const addLoopUndef = (v, dv, cap) => {
        const v1 = loop((v !== null && v !== void 0 ? v : cap) + dv, cap + 1);
        return (v1 === cap) ? undefined : v1;
    };
    return e("svg", Object.assign({ className: cx("SpaceEditor", _css$1), viewBox: "-10 -10 20 20" }, { children: [colorMap.map(color => e("marker", Object.assign({ id: `arrow_${color.substring(1)}`, viewBox: "0 -5 10 10", refX: "10", orient: "auto" }, { children: e("path", { fill: color, d: "M0,-5L10,0L0,5" }) }))), "$", [...hgDiscDots(10)].map(pos => {
                const btnIndex = value.findIndex(b => v3.eq(b.pos, pos));
                const onMouseDown = (ev) => {
                    const kind = btnIndex < 0 ? undefined : value[btnIndex].kind;
                    if (ev.button === 0 || ev.button === 2) {
                        const dx = -(ev.button - 1);
                        let newKind = addLoopUndef(kind, dx, colorMap.length);
                        if (newKind === undefined) {
                            upd({ $splice: [[btnIndex, 1]] });
                        }
                        else if (kind === undefined) {
                            upd({ $push: [{ kind: newKind, pos }] });
                        }
                        else {
                            upd({ [btnIndex]: { kind: { $set: newKind } } });
                        }
                    }
                    if (btnIndex >= 0 && ev.button === 1) {
                        upd({ $splice: [[btnIndex, 1]] });
                    }
                    ev.preventDefault();
                };
                return e(HgCircle, { c: pos, onMouseDown: onMouseDown, onContextMenu: ev => ev.preventDefault(), fill: btnIndex < 0 ? "white" : colorMap[value[btnIndex].kind], stroke: "black", "stroke-width": "0.01", r: "0.3" });
            }), "$", calcForces(forceRules, value)
                .filter(({ vec }) => v3.len(vec) > 0)
                .map(({ target, vec }) => {
                const color = colorMap[target.kind];
                return e(HgLine, { stroke: color, "stroke-width": "0.1", p1: target.pos, p2: v3.add(target.pos, vec), "marker-end": `url(#arrow_${color.substring(1)})`, "pointer-events": "none" });
            })] }));
}

const _css = css `
`;
function App() {
    const colorMap = ["#ff0000", "#00ff00", "#0000ff", "#ffff00", "#00ffff", "#ff00ff"];
    const [forceRules, setForceRules, updForceRules] = useState1([
        {
            sourceKind: 0,
            targetKind: 1,
            radiusKind: 0,
            directionKind: 0
        },
        {
            sourceKind: 1,
            targetKind: 0,
            radiusKind: 1,
            directionKind: 3
        },
        {
            sourceKind: 1,
            targetKind: 0,
            radiusKind: 2,
            directionKind: 3
        }
    ]);
    const [initialSpace, setInitialState] = useState([
        {
            kind: 0,
            pos: axialToCube([1, 3])
        },
        {
            kind: 0,
            pos: axialToCube([-5, 3])
        },
        {
            kind: 1,
            pos: axialToCube([-1, 3])
        },
        {
            kind: 0,
            pos: axialToCube([3, 1])
        },
        {
            kind: 0,
            pos: axialToCube([3, -5])
        },
        {
            kind: 1,
            pos: axialToCube([3, -1])
        }
    ]);
    const spacetime = [
        initialSpace,
        ...pipe(inf(), rx.pipe(rx.scan(s => simulate(forceRules, s), initialSpace), rx.take(99)))
    ];
    useState(["a", "bb", "cdef"]);
    return e("div", Object.assign({ className: cx("App", _css) }, { children: [e(ListEditor, { values: forceRules, defaultValue: {
                    sourceKind: 0,
                    targetKind: 1,
                    radiusKind: 1,
                    directionKind: 0
                }, renderValueEditor: (v, onInput) => e(ForceRuleEditor, { colorMap: colorMap, value: v, onInput: onInput }), onInput: setForceRules, className: ListEditorStyles.boxes }), e(SpaceEditor, { colorMap: colorMap, value: initialSpace, onInput: setInitialState, forceRules: forceRules }), e(SimulationPlayer, { spacetime: spacetime, forceRules: forceRules, colorMap: colorMap }), e("div", { children: useRxSubscribe(() => rx.interval(20).pipe(rx.map(() => new Date().toISOString())), []) })] }));
}

render(e(App, {}), document.body);
</script>
</body>
</html>